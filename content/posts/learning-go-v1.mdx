---
slug: learning-go-v1
title: Learning Go (Part 1)
date: 2022-03-17
tags:
  - go
  - learning
  - backend
hidden: true
---
Exploring languages and differents programming paradigms are quite fun. The first Computer Science class at Grinnell College was a functional programming class in Scheme, a sibling of Lisp. Before college, I had written in some imperative languages like C#, C++, HaXe, etc. so the way I did things and thought about problems was in some sense biased towards a specific direction. As an example, take this problem: `You are given a list of strings. Add up all the strings which represent numbers such as "5" or "3.12" or even "-0.2"` Before Scheme, I would lean towards something like:

```cs
def do_the_thing(lst):
  result = 0
  for x in lst:
    if is_integer(x): # lets assume this exists
      result += to_integer(x)
  return result
```

Although not too much work, it's a little hard to inline and might cause mental bloat if you have a lot of these sprinkled here and there. The way to do this in Scheme would be similar to:

```scheme
(define doTheThing 
  (lambda (lst)
    (reduce
      (lambda (r1 r2) (+ r1 r2))
      (map
        (lambda (m1) 
          (toInt m1)
          (filter
            (lambda (f1)
              (isInt f1)))))))
```

See much better! On second thought, not better at all.. so why is this helpful? Keeping the criticism that the Scheme code was badly written (and it was!), the issue stems from the fact that Scheme can be just a little bit too much verbose and lacking syntactic sugar. Let's see how this might look in a hybrid functional-imperative landscape with C#. Here it goes: 

```cs
int DoTheThing = lst => lst
  .Where(x => IsInt(x))
  .Select(x => ToInt(x))
  .Aggregate((x,y) => x + y)
```